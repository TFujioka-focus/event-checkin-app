<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Event Check-in</title>
    <style>
        :root {
            --pad: 14px;
            --radius: 14px;
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
            margin: 0;
            background: #f6f7f9;
        }

        .wrap {
            max-width: 640px;
            margin: 0 auto;
            padding: var(--pad);
        }

        .card {
            background: #fff;
            border-radius: var(--radius);
            padding: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, .06);
            margin-bottom: 12px;
        }

        h1 {
            font-size: 18px;
            margin: 6px 0 12px;
        }

        label {
            display: block;
            font-size: 12px;
            color: #555;
            margin: 8px 0 4px;
        }

        input,
        select,
        button {
            width: 100%;
            font-size: 16px;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid #d6d8dd;
            box-sizing: border-box;
        }

        button {
            border: 0;
            cursor: pointer;
            font-weight: 700;
        }

        .btn {
            background: #111827;
            color: #fff;
        }

        .btn2 {
            background: #e5e7eb;
            color: #111827;
        }

        .row {
            display: flex;
            gap: 10px;
        }

        .row>* {
            flex: 1;
        }

        .badge {
            display: inline-block;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 999px;
            background: #eef2ff;
            color: #3730a3;
        }

        .status {
            text-align: center;
            padding: 18px 12px;
            border-radius: 16px;
            font-weight: 800;
            font-size: 20px;
            margin-top: 10px;
        }

        .ok {
            background: #eaf7ef;
            color: #065f46;
        }

        .dup {
            background: #fff7ed;
            color: #9a3412;
        }

        .err {
            background: #fef2f2;
            color: #991b1b;
        }

        .meta {
            font-size: 13px;
            color: #374151;
            line-height: 1.6;
            word-break: break-all;
        }

        .small {
            font-size: 12px;
            color: #6b7280;
        }

        .topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .pill {
            background: #f3f4f6;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            color: #111827;
        }

        .hidden {
            display: none;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="card">
            <div class="topbar">
                <h1>å—ä»˜ã‚¢ãƒ—ãƒª</h1>
                <div class="pill">æœªé€ä¿¡: <span id="pendingCount">0</span></div>
            </div>
            <div class="small">
                ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆIDã¯QRã‹ã‚‰å–å¾—ï¼ˆå…¥åŠ›ä¸è¦ï¼‰<br />
                ãƒ»ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚³ãƒ¼ãƒ‰ã¯ç«¯æœ«ã”ã¨ã«1å›ã ã‘è¨­å®šï¼ˆä¾‹: A1 / A2 / B1ï¼‰
            </div>
        </div>

        <!-- Settings -->
        <div class="card" id="settingsCard">
            <div>
                <label>ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚³ãƒ¼ãƒ‰ï¼ˆçŸ­ãï¼‰</label>
                <input id="operatorCode" placeholder="ä¾‹ï¼šA1" inputmode="text" autocomplete="off" />
                <div class="small">ç«¯æœ«ã”ã¨ã«å›ºå®šã€‚æœ€åˆã«1å›ã ã‘å…¥ã‚Œã‚Œã°OKã€‚</div>
            </div>

            <div style="height:10px"></div>
            <div class="row">
                <button class="btn" id="saveSettingsBtn">è¨­å®šã‚’ä¿å­˜ã—ã¦ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹</button>
                <button class="btn2" id="clearSettingsBtn">è¨­å®šã‚¯ãƒªã‚¢</button>
            </div>
        </div>

        <!-- Scanner -->
        <div class="card hidden" id="scanCard">
            <div class="topbar">
                <div>
                    <span class="badge">SCAN</span>
                    <div class="small">ã‚ªãƒšãƒ¬ãƒ¼ã‚¿: <span class="mono" id="operatorLabel"></span></div>
                </div>
                <button class="btn2" id="openSettingsBtn" style="width:auto; padding:10px 12px;">è¨­å®š</button>
            </div>

            <div id="reader"
                style="width:100%; min-height:300px; background:#f3f4f6; border-radius:12px; display:flex; align-items:center; justify-content:center; margin-bottom:12px;">
                <div id="cameraPlaceholder" style="text-align:center; color:#6b7280;">
                    <div style="font-size:48px; margin-bottom:8px;">ğŸ“·</div>
                    <div>ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ã—ã¦ãã ã•ã„</div>
                </div>
            </div>

            <div id="statusBox" class="status hidden"></div>
            <div class="meta" id="metaBox"></div>

            <div style="height:10px"></div>
            <div class="row">
                <button class="btn" id="startCameraBtn">ã‚«ãƒ¡ãƒ©èµ·å‹•</button>
                <button class="btn2" id="retryPendingBtn">æœªé€ä¿¡ã‚’å†é€</button>
            </div>
            <div style="height:6px"></div>
            <div class="row">
                <button class="btn2" id="stopBtn">åœæ­¢</button>
                <button class="btn2" id="openSettingsBtn2" style="width:auto; padding:10px 12px;">è¨­å®š</button>
            </div>
        </div>

        <div class="card hidden" id="debugCard">
            <div class="small">ãƒ‡ãƒãƒƒã‚°</div>
            <div class="mono small" id="debugLog"></div>
        </div>
    </div>

    <!-- QR Scanner library -->
    <script src="https://unpkg.com/html5-qrcode@2.3.10/minified/html5-qrcode.min.js"></script>

    <script>
        // -----------------------------
        // Configuration (åŸ‹ã‚è¾¼ã¿è¨­å®š)
        // -----------------------------
        const GAS_ENDPOINT = "https://script.google.com/macros/s/AKfycbxgsHcf7_twzz9lHBZA35ncVLpfHAs7gVpwgE99wdly6JjvS870yO5L_5mwT3nDWP1l/exec"; // GAS Webã‚¢ãƒ—ãƒªURLã‚’ã“ã“ã«å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: https://script.google.com/macros/s/xxxxx/execï¼‰
        const API_KEY = "plt2026_9fK3dA2xQmL8"; // APIã‚­ãƒ¼ã‚’ã“ã“ã«å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç©ºæ¬„ã§ã‚‚OKï¼‰

        // -----------------------------
        // Storage keys
        // -----------------------------
        const LS = {
            operatorCode: "checkin_operator_code",
            deviceId: "checkin_device_id",
            pending: "checkin_pending_queue"
        };

        // -----------------------------
        // UI elements
        // -----------------------------
        const settingsCard = document.getElementById("settingsCard");
        const scanCard = document.getElementById("scanCard");
        const operatorCodeInput = document.getElementById("operatorCode");
        const operatorLabel = document.getElementById("operatorLabel");
        const pendingCountEl = document.getElementById("pendingCount");
        const statusBox = document.getElementById("statusBox");
        const metaBox = document.getElementById("metaBox");
        const debugLog = document.getElementById("debugLog");
        const debugCard = document.getElementById("debugCard");

        const saveSettingsBtn = document.getElementById("saveSettingsBtn");
        const clearSettingsBtn = document.getElementById("clearSettingsBtn");
        const openSettingsBtn = document.getElementById("openSettingsBtn");
        const openSettingsBtn2 = document.getElementById("openSettingsBtn2");
        const retryPendingBtn = document.getElementById("retryPendingBtn");
        const stopBtn = document.getElementById("stopBtn");
        const startCameraBtn = document.getElementById("startCameraBtn");
        const cameraPlaceholder = document.getElementById("cameraPlaceholder");

        // -----------------------------
        // Helpers
        // -----------------------------
        function log(msg) {
            const ts = new Date().toISOString();
            debugLog.innerText = `[${ts}] ${msg}\n` + debugLog.innerText;
            // ãƒ‡ãƒãƒƒã‚°ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼ˆiOSãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            debugCard.classList.remove("hidden");
            console.log(`[${ts}] ${msg}`);
        }

        function vibrate(ms = 40) {
            try { if (navigator.vibrate) navigator.vibrate(ms); } catch { }
        }

        function beep() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = "sine";
                osc.frequency.value = 880;
                gain.gain.value = 0.03;
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start();
                setTimeout(() => { osc.stop(); ctx.close(); }, 120);
            } catch { }
        }

        function getOrCreateDeviceId() {
            let id = localStorage.getItem(LS.deviceId);
            if (!id) {
                id = "dev_" + crypto.getRandomValues(new Uint32Array(4)).join("");
                localStorage.setItem(LS.deviceId, id);
            }
            return id;
        }

        function loadPending() {
            try {
                const raw = localStorage.getItem(LS.pending);
                return raw ? JSON.parse(raw) : [];
            } catch {
                return [];
            }
        }

        function savePending(queue) {
            localStorage.setItem(LS.pending, JSON.stringify(queue));
            pendingCountEl.textContent = String(queue.length);
        }

        function addPending(item) {
            const q = loadPending();
            q.push(item);
            savePending(q);
        }

        function shiftPending() {
            const q = loadPending();
            const item = q.shift();
            savePending(q);
            return item;
        }

        function setStatus(kind, title, detailObj) {
            statusBox.classList.remove("hidden", "ok", "dup", "err");
            statusBox.classList.add(kind);
            statusBox.textContent = title;

            const lines = [];
            if (detailObj) {
                for (const [k, v] of Object.entries(detailObj)) {
                    if (v !== undefined && v !== null && String(v).length) {
                        lines.push(`${k}: ${v}`);
                    }
                }
            }
            metaBox.innerHTML = lines.length ? `<div class="meta">${lines.join("<br/>")}</div>` : "";
        }

        function clearStatusSoon(ms = 900) {
            setTimeout(() => {
                statusBox.classList.add("hidden");
                metaBox.innerHTML = "";
            }, ms);
        }

        // Parse QR payload: expects querystring-like.
        // Supports:
        //  - "event=XXX&pid=U001&cat=å‚åŠ è€…&team=A&mentor=ä½è—¤"
        //  - full URL containing ?event=...&pid=...
        function parseQr(text) {
            let q = text;
            try {
                if (text.includes("?")) q = text.split("?")[1];
            } catch { }
            q = q.replace(/^#/, "");
            const params = new URLSearchParams(q);
            const event_id = params.get("event") || params.get("event_id") || "";
            const participant_id = params.get("pid") || params.get("participant_id") || "";
            const category = params.get("cat") || params.get("category") || "";
            const team = params.get("team") || "";
            const mentor = params.get("mentor") || "";
            return { event_id, participant_id, category, team, mentor, raw: text };
        }

        function validateOperatorCode(code) {
            // ultra-simple: 1-6 chars, alnum only recommended
            const c = (code || "").trim();
            if (!c) return { ok: false, reason: "ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼šA1ï¼‰" };
            if (c.length > 8) return { ok: false, reason: "ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚³ãƒ¼ãƒ‰ãŒé•·ã™ãã¾ã™ï¼ˆ8æ–‡å­—ä»¥å†…ï¼‰" };
            return { ok: true, value: c };
        }

        // -----------------------------
        // Networking
        // -----------------------------
        async function postCheckin(payload, endpoint, apiKey) {
            const headers = { "Content-Type": "application/json" };
            if (apiKey && apiKey.trim()) headers["X-API-KEY"] = apiKey.trim();

            const res = await fetch(endpoint, {
                method: "POST",
                headers,
                body: JSON.stringify(payload),
            });

            const contentType = res.headers.get("content-type") || "";
            let data = null;
            if (contentType.includes("application/json")) {
                data = await res.json();
            } else {
                const t = await res.text();
                try { data = JSON.parse(t); } catch { data = { raw: t }; }
            }

            if (!res.ok) {
                const errMsg = (data && (data.error || data.message)) ? (data.error || data.message) : `HTTP ${res.status}`;
                throw new Error(errMsg);
            }
            return data;
        }

        async function flushPending(endpoint, apiKey) {
            const q = loadPending();
            if (!q.length) return { sent: 0 };

            let sent = 0;
            // try sequentially to avoid bursts
            for (let i = 0; i < 50; i++) {
                const item = loadPending()[0];
                if (!item) break;
                try {
                    await postCheckin(item, endpoint, apiKey);
                    shiftPending();
                    sent++;
                } catch (e) {
                    // stop at first failure
                    log("pending flush failed: " + e.message);
                    break;
                }
            }
            return { sent };
        }

        // -----------------------------
        // Scanner
        // -----------------------------
        let html5QrCode = null;
        let scanning = false;
        let lastScan = { key: "", at: 0 };

        async function handleQrScan(decodedText, operator_code, endpoint, apiKey, device_id) {
            // Debounce duplicates (same raw within 2 sec)
            const now = Date.now();
            const parsed = parseQr(decodedText);
            const key = `${parsed.event_id}|${parsed.participant_id}|${parsed.raw}`;
            if (key === lastScan.key && (now - lastScan.at) < 2000) return;
            lastScan = { key, at: now };

            // Basic validation
            if (!parsed.event_id || !parsed.participant_id) {
                vibrate(120);
                setStatus("err", "QRå½¢å¼ã‚¨ãƒ©ãƒ¼", {
                    required: "event ã¨ pid ãŒå¿…è¦",
                    raw: decodedText.slice(0, 120) + (decodedText.length > 120 ? "..." : "")
                });
                clearStatusSoon(1200);
                return;
            }

            // Pause scanning during submit to reduce double fires
            scanning = false;

            const payload = {
                timestamp_client: new Date().toISOString(),
                event_id: parsed.event_id,
                participant_id: parsed.participant_id,
                category: parsed.category || "",
                team: parsed.team || "",
                mentor: parsed.mentor || "",
                operator_code,
                device_id,
            };

            try {
                const data = await postCheckin(payload, endpoint, apiKey);

                // Expected response shape:
                // { status: "OK"|"DUPLICATE", message?: "...", ... }
                const st = (data && (data.status || data.result)) ? (data.status || data.result) : "OK";

                if (String(st).toUpperCase() === "DUPLICATE") {
                    vibrate(90);
                    setStatus("dup", "å—ä»˜æ¸ˆã¿", {
                        event: parsed.event_id,
                        pid: parsed.participant_id,
                        note: data.message || ""
                    });
                } else {
                    beep(); vibrate(40);
                    setStatus("ok", "å—ä»˜å®Œäº†", {
                        event: parsed.event_id,
                        pid: parsed.participant_id,
                        cat: parsed.category || "",
                        team: parsed.team || "",
                        mentor: parsed.mentor || ""
                    });
                }
            } catch (e) {
                // Queue if network error
                addPending(payload);
                vibrate(140);
                setStatus("err", "é€šä¿¡ã‚¨ãƒ©ãƒ¼ï¼ˆæœªé€ä¿¡ã«ä¿å­˜ï¼‰", {
                    event: parsed.event_id,
                    pid: parsed.participant_id,
                    error: e.message
                });
            } finally {
                // Resume scanning after short delay
                clearStatusSoon(900);
                setTimeout(() => { scanning = true; }, 650);
            }
        }

        async function startCamera() {
            const operator_code = localStorage.getItem(LS.operatorCode) || "";
            const endpoint = GAS_ENDPOINT;
            const apiKey = API_KEY;
            const device_id = getOrCreateDeviceId();

            if (!operator_code) {
                setStatus("err", "è¨­å®šã‚¨ãƒ©ãƒ¼", { reason: "ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚³ãƒ¼ãƒ‰ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“" });
                showSettings();
                return;
            }

            if (!endpoint) {
                setStatus("err", "è¨­å®šã‚¨ãƒ©ãƒ¼", { reason: "GAS_ENDPOINTãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“" });
                showSettings();
                return;
            }

            // ã‚«ãƒ¡ãƒ©èµ·å‹•ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
            startCameraBtn.disabled = true;
            startCameraBtn.textContent = "ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­...";

            // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’éè¡¨ç¤º
            if (cameraPlaceholder) {
                cameraPlaceholder.style.display = "none";
            }

            if (!html5QrCode) html5QrCode = new Html5Qrcode("reader");

            // iOSå¯¾å¿œ: ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­å®šï¼ˆvideoConstraintsã¯ä½¿ã‚ãªã„ï¼‰
            const config = {
                fps: 10,
                qrbox: { width: 250, height: 250 },
                aspectRatio: 1.0,
                disableFlip: false
            };

            scanning = true;
            log("ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚’é–‹å§‹...");
            log("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: " + navigator.userAgent);

            // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ10ç§’ï¼‰
            const timeoutId = setTimeout(() => {
                if (startCameraBtn.disabled) {
                    log("ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ");
                    setStatus("err", "ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ", {
                        hint: "ã‚«ãƒ¡ãƒ©ã®æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
                    });
                    scanning = false;
                    startCameraBtn.disabled = false;
                    startCameraBtn.textContent = "ã‚«ãƒ¡ãƒ©èµ·å‹•";
                    if (cameraPlaceholder) {
                        cameraPlaceholder.style.display = "block";
                    }
                }
            }, 10000);

            try {
                // iOSå¯¾å¿œ: ã¾ãšç’°å¢ƒã‚«ãƒ¡ãƒ©ã‚’ç›´æ¥è©¦ã™ï¼ˆæœ€ã‚‚ç¢ºå®Ÿãªæ–¹æ³•ï¼‰
                log("ç’°å¢ƒã‚«ãƒ¡ãƒ©ã§ç›´æ¥èµ·å‹•ã‚’è©¦è¡Œä¸­...");
                try {
                    await html5QrCode.start(
                        { facingMode: "environment" },
                        config,
                        async (decodedText) => {
                            if (!scanning) return;
                            log("QRã‚³ãƒ¼ãƒ‰æ¤œå‡º: " + decodedText.substring(0, 50));
                            await handleQrScan(decodedText, operator_code, endpoint, apiKey, device_id);
                        },
                        (err) => {
                            // ã‚¹ã‚­ãƒ£ãƒ³ä¸­ã®ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆç¶™ç¶šçš„ã«ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹ãŸã‚ï¼‰
                        }
                    );
                    clearTimeout(timeoutId);
                    log("ã‚«ãƒ¡ãƒ©èµ·å‹•æˆåŠŸï¼ˆç’°å¢ƒã‚«ãƒ¡ãƒ©ç›´æ¥æŒ‡å®šï¼‰");
                    startCameraBtn.style.display = "none";
                    setStatus("ok", "ã‚«ãƒ¡ãƒ©èµ·å‹•æˆåŠŸ", { note: "QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„" });
                    clearStatusSoon(2000);
                    return;
                } catch (e2) {
                    log("ç’°å¢ƒã‚«ãƒ¡ãƒ©ç›´æ¥èµ·å‹•å¤±æ•—: " + e2.message);
                    log("ã‚¨ãƒ©ãƒ¼è©³ç´°: " + JSON.stringify(e2));
                    // ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã‹ã‚‰è©¦ã™
                }

                // ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã‹ã‚‰é¸æŠã‚’è©¦ã™
                let cameras = [];
                try {
                    log("ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã‚’å–å¾—ä¸­...");
                    cameras = await Html5Qrcode.getCameras();
                    log(`ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆå–å¾—æˆåŠŸ: ${cameras.length}å°`);
                } catch (e) {
                    log("ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: " + e.message);
                    throw new Error("ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                }

                if (!cameras || cameras.length === 0) {
                    throw new Error("åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
                }

                log(`åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ¡ãƒ©æ•°: ${cameras.length}`);

                // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆçš„ã«é¸æŠï¼ˆç’°å¢ƒã‚«ãƒ¡ãƒ©ã‚’æ¢ã™ï¼‰
                let camId = null;
                for (let i = cameras.length - 1; i >= 0; i--) {
                    const cam = cameras[i];
                    const label = (cam.label || "").toLowerCase();
                    log(`ã‚«ãƒ¡ãƒ© ${i}: ${label || cam.id}`);
                    if (label.includes("back") || label.includes("rear") || label.includes("ç’°å¢ƒ") || label.includes("environment")) {
                        camId = cam.id;
                        log(`èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’é¸æŠ: ${camId}`);
                        break;
                    }
                }
                // èƒŒé¢ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æœ€å¾Œã®ã‚«ãƒ¡ãƒ©ã‚’ä½¿ç”¨
                if (!camId) {
                    camId = cameras[cameras.length - 1].id;
                    log(`æœ€å¾Œã®ã‚«ãƒ¡ãƒ©ã‚’é¸æŠ: ${camId}`);
                }

                log(`ã‚«ãƒ¡ãƒ©ID ${camId} ã§èµ·å‹•ã‚’è©¦è¡Œä¸­...`);
                await html5QrCode.start(
                    camId,
                    config,
                    async (decodedText) => {
                        if (!scanning) return;
                        log("QRã‚³ãƒ¼ãƒ‰æ¤œå‡º: " + decodedText.substring(0, 50));
                        await handleQrScan(decodedText, operator_code, endpoint, apiKey, device_id);
                    },
                    (err) => {
                        // ã‚¹ã‚­ãƒ£ãƒ³ä¸­ã®ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆç¶™ç¶šçš„ã«ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹ãŸã‚ï¼‰
                    }
                );
                clearTimeout(timeoutId);
                log("ã‚«ãƒ¡ãƒ©èµ·å‹•æˆåŠŸï¼ˆã‚«ãƒ¡ãƒ©IDæŒ‡å®šï¼‰");
                startCameraBtn.style.display = "none";
                setStatus("ok", "ã‚«ãƒ¡ãƒ©èµ·å‹•æˆåŠŸ", { note: "QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„" });
                clearStatusSoon(2000);
            } catch (e) {
                clearTimeout(timeoutId);
                scanning = false;
                const errorMsg = e.message || String(e);
                log("ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹å¤±æ•—: " + errorMsg);
                log("ã‚¨ãƒ©ãƒ¼è©³ç´°: " + JSON.stringify(e));
                log("ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯: " + (e.stack || "ãªã—"));

                // iOSç‰¹æœ‰ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                let hint = "ã‚«ãƒ¡ãƒ©ã®æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    hint += " iOSã§ã¯Safariãƒ–ãƒ©ã‚¦ã‚¶ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™ã€‚";
                }

                setStatus("err", "ã‚«ãƒ¡ãƒ©èµ·å‹•å¤±æ•—", {
                    error: errorMsg,
                    hint: hint
                });
                startCameraBtn.disabled = false;
                startCameraBtn.textContent = "ã‚«ãƒ¡ãƒ©èµ·å‹•";
                if (cameraPlaceholder) {
                    cameraPlaceholder.style.display = "block";
                }
            }
        }

        async function startScanner() {
            const operator_code = localStorage.getItem(LS.operatorCode) || "";
            const endpoint = GAS_ENDPOINT;
            const apiKey = API_KEY;
            const device_id = getOrCreateDeviceId();

            if (!endpoint) {
                setStatus("err", "è¨­å®šã‚¨ãƒ©ãƒ¼", { reason: "GAS_ENDPOINTãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“" });
                showSettings();
                return;
            }

            operatorLabel.textContent = operator_code;

            // UI
            settingsCard.classList.add("hidden");
            scanCard.classList.remove("hidden");

            pendingCountEl.textContent = String(loadPending().length);

            // Retry pending in background on start (best effort)
            flushPending(endpoint, apiKey).catch(() => { });

            // ã‚«ãƒ¡ãƒ©èµ·å‹•ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (startCameraBtn) {
                startCameraBtn.style.display = "block";
                startCameraBtn.disabled = false;
                startCameraBtn.textContent = "ã‚«ãƒ¡ãƒ©èµ·å‹•";
            }
            if (cameraPlaceholder) {
                cameraPlaceholder.style.display = "block";
            }
        }

        async function stopScanner() {
            scanning = false;
            try {
                if (html5QrCode && html5QrCode.isScanning) {
                    await html5QrCode.stop();
                }
            } catch { }
            // ã‚«ãƒ¡ãƒ©åœæ­¢æ™‚ã«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (startCameraBtn) {
                startCameraBtn.style.display = "block";
                startCameraBtn.disabled = false;
                startCameraBtn.textContent = "ã‚«ãƒ¡ãƒ©èµ·å‹•";
            }
            if (cameraPlaceholder) {
                cameraPlaceholder.style.display = "block";
            }
        }

        // -----------------------------
        // Settings + Boot
        // -----------------------------
        function showSettings() {
            scanCard.classList.add("hidden");
            settingsCard.classList.remove("hidden");

            operatorCodeInput.value = localStorage.getItem(LS.operatorCode) || "";
            pendingCountEl.textContent = String(loadPending().length);
        }

        saveSettingsBtn.addEventListener("click", async () => {
            const op = validateOperatorCode(operatorCodeInput.value);
            if (!op.ok) {
                setStatus("err", "è¨­å®šã‚¨ãƒ©ãƒ¼", { reason: op.reason });
                // show in settings card by temporarily placing status
                settingsCard.insertAdjacentElement("beforeend", statusBox);
                statusBox.classList.remove("hidden");
                return;
            }

            if (!GAS_ENDPOINT) {
                setStatus("err", "è¨­å®šã‚¨ãƒ©ãƒ¼", { reason: "GAS_ENDPOINTãŒã‚³ãƒ¼ãƒ‰ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“" });
                settingsCard.insertAdjacentElement("beforeend", statusBox);
                statusBox.classList.remove("hidden");
                return;
            }

            localStorage.setItem(LS.operatorCode, op.value);

            // move statusBox back (if it was attached)
            statusBox.classList.add("hidden");
            document.body.appendChild(statusBox);

            await stopScanner();
            await startScanner();
        });

        clearSettingsBtn.addEventListener("click", async () => {
            localStorage.removeItem(LS.operatorCode);
            showSettings();
            await stopScanner();
        });

        openSettingsBtn.addEventListener("click", async () => {
            showSettings();
            await stopScanner();
        });

        if (openSettingsBtn2) {
            openSettingsBtn2.addEventListener("click", async () => {
                showSettings();
                await stopScanner();
            });
        }

        if (startCameraBtn) {
            startCameraBtn.addEventListener("click", async () => {
                await startCamera();
            });
        }

        retryPendingBtn.addEventListener("click", async () => {
            const endpoint = GAS_ENDPOINT;
            const apiKey = API_KEY;
            if (!endpoint) {
                setStatus("err", "è¨­å®šã‚¨ãƒ©ãƒ¼", { reason: "GAS_ENDPOINTãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“" });
                clearStatusSoon(1200);
                return;
            }
            const r = await flushPending(endpoint, apiKey);
            if (r.sent > 0) {
                beep(); vibrate(40);
                setStatus("ok", "å†é€å®Œäº†", { sent: r.sent });
            } else {
                setStatus("dup", "å†é€ãªã—", { note: "æœªé€ä¿¡ãŒãªã„ã‹ã€é€šä¿¡ã‚¨ãƒ©ãƒ¼ã§ã™" });
            }
            clearStatusSoon(1000);
        });

        stopBtn.addEventListener("click", async () => {
            await stopScanner();
            setStatus("dup", "åœæ­¢ã—ã¾ã—ãŸ", { note: "å†é–‹ã™ã‚‹ã«ã¯è¨­å®šâ†’ä¿å­˜" });
        });

        // Boot
        (function init() {
            // ensure device id
            getOrCreateDeviceId();

            // show settings if missing operator code or endpoint
            const op = localStorage.getItem(LS.operatorCode);
            if (!op || !GAS_ENDPOINT) {
                showSettings();
            } else {
                // start scanner immediately
                startScanner();
            }

            pendingCountEl.textContent = String(loadPending().length);
        })();
    </script>
</body>

</html>
